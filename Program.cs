using System;
using System.Collections.Generic;
using System.Linq;

namespace LC
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            //GetEvenCount(new int[] { 555, 901, 482, 1771 });
            //SortedSquares(new int[] { -7, -3, 2, 3, 11 });
            //CanPermutePalindrome("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc");
            //CanFormArray(new int[] { 91, 4, 64, 78, 12, 45, 11, 2}, new int[][] { new int[] { 78, 12 }, new int[] { 91, 4,64 }, new int[] {2 }, new int[] { 45, 11 } });
            //DuplicateZeros(new int[] { 8, 4, 5, 0, 0, 0, 0, 7 });
            //RemoveElement(new int[] { 0, 1, 2, 2, 3, 0, 4, 2 }, 2);
            //Sorting.SelectionSort(new int[] { 64, 25, 12, 22, 11 });
            //Sorting.BubleSort(new int[] { 64, 25, 12, 22, 11 });
            //Sorting.InsertionSort(new int[] { 534,5332,654,3356,34,665,23243,6766,33433,75656,344,886,343,65 });
            //Sorting.MergeSort(new int[] { 64, 25, 12, 22, 11 });
            //Sorting.MinimumWaitingTime(new int[] {3,2,1,2,6 });
            //Recussion.LetterCombinations("23");
            //Recussion.Get_Permutations_No_Dups(new List<int> { 1,2,2 });
            //Recussion.generate_all_expressions("22", 4);
            //Recussion.generate_all_combinations(new List<int> { 1, 1,1,1 }, 2);
            //Graphs.can_be_divided(5, new List<int> { 0, 1, 1, 2, 3 }, new List<int> { 2, 2, 4, 3, 4 });
            //var islands = new List<List<int>>
            //{
            //    new List<int> { 1, 0, 0, 0, 1, 0, 1  },
            //    new List<int> { 0, 1, 0, 0, 0, 1, 0  },
            //    new List<int> { 0, 0, 1, 0, 0, 0, 1  },
            //    new List<int> { 0, 0, 0, 1, 0, 0, 0  },
            //    new List<int> { 0, 0, 0, 0, 1, 0, 0  }
            //};
            //Islands.count_islands(islands);

            //Graphs.can_be_completed(4, new List<int> { 1, 1, 3 }, new List<int> { 0, 2, 1 });can_be_completed_kahns
            //Graphs.can_be_completed_kahns(14, new List<int> { 0,5,5,3,3,6,6,1,9,10,12}, new List<int> { 3,6,7,1,2,4,8,0,10,11,13 }); 

            //Sorting.ThreeSum(new int[] { -1, 0, 1, 2, -1, -4 });
            //Strings.LengthOfLongestSubstring("abcabcbb");
            //Strings.rotationalCipher("abcdefghijklmNOPQRSTUVWXYZ0123456789", 39);
            //Strings.rotationalCipher("1", 2);
            //Strings.numberOfWays(new int[] { 1, 5, 3, 3, 3 }, 6);
            //Recussion.get_distinct_subsets("aab");
            //Recussion.generate_all_combinations_unique(new List<int> { 1, 1, 1, 1 }, 2);
            //Recussion.check_if_sum_possible(new long[] { 1 }, 0);
            //DP.levenshteinDistance("pizza", "yolo");
            //DP.MinNumberOfCoinsForChange(7, new int[] { 2, 4 });
            //DP.MaxSumIncreasingSubsequences(new int[] { 8,12,2,3,15,5,7 });
            //DP.LongestCommonSubsequence("ZXVVYZW", "XKYKZPW");
            //DP.WaterArea(new int[] { 0, 8, 0, 0, 5, 0, 0, 10, 0, 0, 1, 1, 0, 3 });
            //DP.NumDecodingsTabulation("226");
            //DP.MinCost(new int[][] { new int[] { 3, 5, 3 }, new int[] { 6, 17, 6 }, new int[] { 7, 13, 18 }, new int[] { 9, 10, 18 } });
            //DP.IsInterleave("abc", "bcd", "abcbdc");
            //DP.MaxProfitWithKTransactions(new int[] { 5,11,3,50,60,90 }, 2);
            //DP.WordBreak("leetcode", new List<string> { "leet", "code" });
            //DP.LeastBricks(new List<IList<int>> { new List<int> { 1, 2, 2, 1 }, new List<int> { 3, 1, 2 }, new List<int> { 1, 3, 2 }, new List<int> { 2, 4 }, new List<int> { 3, 1, 2 }, new List<int> { 1, 3, 1, 1 } });
            //DP.LeastBricks(new List<IList<int>> { new List<int> { 1 }, new List<int> { 1 }, new List<int> { 1 } });
            //Graphs.RiverSizes(new int[5, 5] { { 1, 0, 0, 1, 0 }, { 1, 0, 1, 0, 0 }, { 0, 0, 1, 0, 1 }, { 1, 0, 1, 0, 1 }, { 1, 0, 1, 1, 0 } });
            //Graphs.HasSingleCycle(new int[] {2,3,1,-4,-4,2 });
            //Graphs.CycleInGraph(new int[][] { new int [] { 1,3 }, new int[] { 2,3,4  }, new int[] { 0 }, new int[] { }, new int[] { 2, 5 }, new int[] { } });
            //Graphs.CycleInUndirectedGraph(new int[][] { new int[] { 1, 2 }, new int[] { 2 }, new int[] {  } });
            //Graphs.MinimumPassesOfMatrix(new int[][] { new int[] { 0,-2,-1 }, new int[] { -5,2,0 }, new int[] { -6,-2,0 } });
            //Graphs.MinimumPassesOfMatrix(new int[][] { new int[] { 1, 0, 0, -2, -3 }, new int[] { -4, -5, -6, -2, -1 }, new int[] { 0, 0, 0, 0, -1 }, new int[] { 1, 2, 3, 0, -2 } });
            //Sorting.FindUnsortedSubarray(new int[] { 2,1 });
            //Graphs.NumIslands(new char[][] { new char[] { '1','1','1','1','0' }, new char[] { '1', '1', '0', '1', '0' }, new char[] { '1', '1', '0', '0', '0' }, new char[] { '0', '0', '0', '0', '0' } });
            //Strings.decodeString(3, "mnes__ya_____mi");
            //Strings.decodeString(2, "hlowrd_el_ol");
            //SlidingWindow.MaxSubArrayLen(new int[] { -2, -1, 2, 1 }, 1);
            //SlidingWindow.find_top_k_frequent_elements(new List<int> { 1, 2, 1, 2, 3, 1 }, 1);
            //SlidingWindow.subarraySum_contains(new int[] { 1, 3, 5, 23, 2 }, 7);
            //BitManipulation.GetSum(10, 2);
            //BitManipulation.LargestIsland(new int[][] { new int[] { 0, 0 }, new int[] { 0, 1 } });
            //SlidingWindow.CountZeroSumSlices(new int[] { 2, -2, 3, 0, 4, -7 });
            //SlidingWindow.ValidPalindrome("abc");
            SubarraySum(new int[] { 1, 1, 1 }, 2);
        }

        public static int SubarraySum(int[] nums, int k)
        {
            int count = 0, sum = 0;
            Dictionary<int, int> map = new Dictionary<int, int>();
            map.Add(0, 1);
            for (int i = 0; i < nums.Length; i++)
            {
                sum += nums[i];
                Console.WriteLine($"sum: {sum}");
                if (map.ContainsKey(sum - k))
                    count += map[sum - k];
                if (!map.ContainsKey(sum))
                    map.Add(sum, 0);
                map[sum]++;
            }
            return count;
        }

        public static int GetEvenCount(int[] nums)
        {
            int count = 0;
            int numCount = 0;

            if (nums.Length == 0)
                return 0;

            for (int i = 0; i < nums.Length; i++)
            {
                int n = nums[i];
                while (n > 0)
                {
                    n /= 10;
                    numCount++;
                }
                if (numCount % 2 == 0)
                    count++;
                numCount = 0;
            }
            return count;
        }

        public static int[] SortedSquares(int[] nums)
        {
            int[] outArr = new int[nums.Length];
            int start = 0;
            int end = nums.Length - 1;
            int pointer = nums.Length - 1;

            while (start <= end)
            {
                int sq1 = nums[start] * nums[start];
                int sq2 = nums[end] * nums[end];

                if (sq1 > sq2)
                {
                    outArr[pointer] = sq1;
                    pointer--;
                    start++;
                }
                else
                {
                    outArr[pointer] = sq2;
                    pointer--;
                    end--;
                }
            }
            return outArr;
        }

        public static bool CanPermutePalindrome(string s)
        {
           if (s.Length == 1)
                return true;
            Dictionary<char, int> charCount = new Dictionary<char, int>();

            for (int i = 0; i < s.Length; i++)
            {
                if (charCount.ContainsKey(s[i]))
                {
                    charCount[s[i]]++;
                }
                else
                {
                    charCount.Add(s[i], 1);
                }
            }

            int oddCount = 0;

            foreach (var count in charCount)
            {
                if (count.Value % 2 != 0)
                    oddCount++;
            }
            return oddCount == 0 || oddCount == 1;
        }

        public static bool CanFormArray(int[] arr, int[][] pieces)
        {
            int n = arr.Length;
            var dict = new Dictionary<int, int[]>();

            foreach (var p in pieces)
            {
                dict.Add(p[0], p);
            }

            int i = 0;
            while (i < n)
            {
                if (!dict.ContainsKey(arr[i]))
                    return false;

                int[] targetPiece = dict[arr[i]];
                foreach (var p in targetPiece)
                {
                    if (p != arr[i])
                        return false;
                    i++;
                }
            }

            return true;
        }
        public static void DuplicateZeros(int[] arr)
        {

            int possibleDups = 0;
            int length_ = arr.Length - 1;

            // Find the number of zeros to be duplicated
            // Stopping when left points beyond the last element in the original array
            // which would be part of the modified array
            for (int left = 0; left <= length_ - possibleDups; left++)
            {

                // Count the zeros
                if (arr[left] == 0)
                {

                    // Edge case: This zero can't be duplicated. We have no more space,
                    // as left is pointing to the last element which could be included  
                    if (left == length_ - possibleDups)
                    {
                        // For this zero we just copy it without duplication.
                        arr[length_] = 0;
                        length_ -= 1;
                        break;
                    }
                    possibleDups++;
                }
            }

            // Start backwards from the last element which would be part of new array.
            int last = length_ - possibleDups;

            // Copy zero twice, and non zero once.
            for (int i = last; i >= 0; i--)
            {
                if (arr[i] == 0)
                {
                    arr[i + possibleDups] = 0;
                    possibleDups--;
                    arr[i + possibleDups] = 0;
                }
                else
                {
                    arr[i + possibleDups] = arr[i];
                }
            }
        }
        public static int RemoveElement(int[] nums, int val)
        {
            int valIdx = -1;
            int nonValCount = 0;
            int len = nums.Length;
            int i = 0;

            while (i < len)
            {
                if (nums[i] != val)
                    nonValCount++;

                if (nums[i] == val && valIdx == -1)
                    valIdx = i;
                else if (nums[i] != val && valIdx != -1)
                {
                    int temp = nums[i];
                    nums[i] = nums[valIdx];
                    nums[valIdx] = temp;
                    valIdx++;
                }
                i++;
            }
            return nonValCount;
        }


    }
}
